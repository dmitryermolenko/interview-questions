### Содержание

| № | Вопрос                                                                                                                                                              |
|---|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|   | [Что такое React?](#что-такое-react)                                                                                                                                |
|   | [Какие основные преимущества использования React?](#какие-основные-преимущества-использования-react)                                                                |
|   | [Что такое Virtual DOM, и как он работает?](#что-такое-virtual-dom-и-как-он-работает)                                                                               |
|   | [Как работает алгоритм согласования (reconciliation) в React?](#как-работает-алгоритм-согласования-reconciliation-в-react)                                          |
|   | [Что такое ключи (keys) и зачем они нужны?](#что-такое-ключи-keys-и-зачем-они-нужны)                                                                                |
|   | [Является ли key обязательным?](#является-ли-key-обязательным)                                                                                                      |
|   | [Можем ли мы в качестве key использовать индекс элемента массива?](#можем-ли-мы-в-качестве-key-использовать-индекс-элемента-массива)                                |
|   | [Что можно использовать в качестве key как альтернатива индексу элемента массива?](что-можно-использовать-в-качестве-key-как-альтернатива-индексу-элемента-массива?) |
|   | [С какой версией React приходилось работать?](с-какой-версией-React-приходилось-работать)                                                                           |
|   | [Какие методы жизненного цикла компонентов вы знаете?](#какие-методы-жизненного-цикла-компонентов-вы-знаете)                                                        |
|   | [Какие методы жизненного цикла были убраны в React 16?](#какие-методы-жизненного-цикла-были-убраны-в-react-16)                                                      |
|   | [Какие нововведения были добавлены в React 16?](#какие-нововведения-были-добавлены-в-react-16)                                                                      |
|   | [Что такое "хуки" (hooks) в React и для чего они используются?](#что-такое-хуки-hooks-в-react-и-для-чего-они-используются)                                          |
|   | [Какие знаешь хуки?](#какие-знаешь-хуки?)                                                                                                                           |
|   | [Какие хуки используешь на работе?](#какие-хуки-используешь-на-работе)
|   | [Какой хук является аналогом componentDidMount?](какой-хук-является-аналогом-componentDidMount)                                                                     |
|   | [Как работает хук `useEffect`?](как-работает-хук-useEffect)                                                                                                         |
|   | [Какова основная роль `useEffect`?](какова-основная-роль-useEffect)?                                                                                                |
|   | [Какие параметры принимает `useEffect`?]()                                                                                                                          |
|   | [Как работает `useEffect`, если список зависимостей пуст?]()                                                                                                        |
|   | [Как работает `useEffect`, если нет списка зависимостей? ]()                                                                                                        |
|   | [Как работает `useEffect`, если есть список зависимостей?]()                                                                                                        |
|   | [Что может возвращать `useEffect`?]()                                                                                                                               |
|   | [Можно ли очистить эффект? Если да, то как?]() |
|   | [Что такое cleanup функция?]() |
|   | [Когда вызывается cleanup функция?]() |
|   | [Как работает `useEffect`, если есть список зависимостей и cleanup функция?]()
|   | [Какие особенности имеют хуки `useEffect` и `useLayoutEffect`?](#какие-особенности-имеют-хуки-useeffect-и-uselayouteffect)                                          |
|   | [Что такое контекст (context) в React и для чего он используется?](#что-такое-контекст-context-в-react-и-для-чего-он-используется)                                  |


### Что такое React?

React - это библиотека JavaScript, разработанная компанией Facebook, которая используется для создания пользовательских интерфейсов. Она позволяет разбивать пользовательский интерфейс на небольшие компоненты, которые могут обновляться независимо друг от друга, что обеспечивает эффективное управление состоянием и обновлениями на веб-странице. React использует виртуальное DOM (Document Object Model) для оптимизации производительности, позволяя эффективно обновлять только изменившиеся части интерфейса. Одной из главных концепций React является "однонаправленный поток данных", который облегчает отслеживание изменений и управление состоянием приложения. React широко используется в разработке веб-приложений и мобильных приложений с использованием фреймворка React Native.
**[⬆ Наверх](#содержание)**

### Какие основные преимущества использования React?

Использование React имеет несколько ключевых преимуществ:

1. **Виртуальный DOM:** React использует виртуальный DOM для эффективного управления обновлениями интерфейса. Это позволяет минимизировать операции непосредственно с реальным DOM, что повышает производительность приложения.

2. **Компонентный подход:** React позволяет разбивать пользовательский интерфейс на множество мелких компонентов. Эти компоненты могут быть повторно использованы, что упрощает разработку, тестирование и обслуживание кода.

3. **Однонаправленный поток данных:** Реакт обеспечивает однонаправленный поток данных, что упрощает отслеживание изменений состояния и делает код более предсказуемым и легко поддерживаемым.

4. **Декларативный подход:** React использует декларативный подход стиль программирования, который позволяет описывать, как должен выглядеть интерфейс в зависимости от состояния. Это делает код более читаемым и понятным.

5. **Экосистема и сообщество:** React обладает большой и активной общиной разработчиков, что обеспечивает множество готовых решений, библиотек и инструментов для разработки.

6. **React Native:** Для разработки мобильных приложений можно использовать React Native, который позволяет использовать React для создания нативных мобильных приложений под разные платформы.


**[⬆ Наверх](#содержание)** 

### Что такое Virtual DOM, и как он работает?

Virtual DOM (виртуальное DOM) - это концепция, используемая в библиотеках и фреймворках, таких как React, для оптимизации обновлений реального DOM (Document Object Model) и повышения производительности веб-приложений.

Реальный DOM - это представление структуры веб-страницы в браузере в виде дерева объектов. Когда состояние приложения меняется и требуется обновление интерфейса, браузер выполняет изменения непосредственно в реальном DOM. Однако многократные и частые обновления реального DOM могут быть затратными с точки зрения производительности, особенно для больших и сложных интерфейсов.

Виртуальное DOM решает эту проблему следующим образом:

1. **Создание виртуального DOM:** При изменении состояния приложения React создает виртуальное представление DOM-структуры, которая является легковесной копией реального DOM.

2. **Сравнение виртуального DOM:** React сравнивает предыдущее состояние виртуального DOM с новым состоянием, выявляя, какие части интерфейса были изменены.

3. **Генерация разницы (патч):** На основе сравнения React создает минимальный набор изменений, необходимых для обновления виртуального DOM согласно новому состоянию.

4. **Применение изменений:** Созданные изменения применяются к реальному DOM только одним обновлением, что позволяет избежать множественных манипуляций с реальным DOM.

Использование виртуального DOM позволяет значительно улучшить производительность, так как обновления реального DOM происходят только в необходимых местах. Это также делает разработку более удобной и предсказуемой, поскольку разработчику не нужно ручным образом управлять множеством изменений на реальном DOM.  

**[⬆ Наверх](#содержание)**

### Как работает алгоритм согласования (reconciliation) в React?

Алгоритм согласования в React – это процесс сравнения виртуального DOM (VDOM) предыдущего и текущего состояний компонента, чтобы определить, какие изменения необходимо внести в реальный DOM для отражения нового состояния. Он позволяет минимизировать изменения в DOM и обеспечивает эффективное обновление интерфейса.

Вот как работает алгоритм согласования:

1. **Создание виртуального DOM**:
  - При первом рендеринге компонента React создает виртуальное дерево элементов (виртуальный DOM), представляющее структуру компонентов и их свойства.
2. **Сравнение виртуальных DOM**:

  - Когда компонент перерисовывается, React создает новое виртуальное дерево для нового состояния.
  - Затем сравнивает новое виртуальное дерево с предыдущим, учитывая иерархию и ключи элементов.

3. **Определение изменений**:

  - В результате сравнения React определяет, какие элементы изменились, какие добавились или удалены.
  - Ключи элементов помогают React определить, какие элементы переместились, а какие изменены.

4. **Генерация пакета изменений (diff)**:

  - На основе определенных изменений React генерирует пакет изменений (diff), который описывает, какие изменения нужно внести в реальный DOM.

5. **Применение изменений в DOM**:

  - React применяет пакет изменений к реальному DOM.
  - Это может включать вставку, обновление или удаление элементов в зависимости от типа изменений.

6. **Вызов методов жизненного цикла**:

  - После обновления реального DOM React вызывает соответствующие методы жизненного цикла компонентов (например, `componentDidUpdate`).

7. **Асинхронность и пакетная обработка**:
  - React может группировать несколько обновлений в одну операцию, чтобы уменьшить количество изменений в DOM и оптимизировать производительность.
  - React также может оптимизировать порядок обновлений для более эффективного применения изменений.

Алгоритм согласования позволяет React рендерить компоненты эффективно, минимизируя количество дорогостоящих операций обновления DOM. Это делает React мощной библиотекой для создания быстрых и отзывчивых пользовательских интерфейсов.

**[⬆ Наверх](#содержание)**

### Что такое ключи (keys), и зачем они нужны?

В React, ключи (keys) - это специальные атрибуты, используемые при рендеринге списков компонентов или элементов. Они помогают React оптимизировать процесс обновления и перерисовки компонентов в списках.

Ключи назначаются каждому элементу в списке и должны быть уникальными среди своих соседних элементов. Когда React обновляет список компонентов, он использует ключи для определения, какие элементы были добавлены, удалены или изменены. Без ключей React будет перерисовывать и обновлять все элементы в списке, что может привести к ухудшению производительности.

Пример использования ключей:

```jsx
import React from "react";

const TodoList = ({ todos }) => {
  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
};

export default TodoList;
```

В этом примере каждому элементу списка задач (`todo`) присваивается уникальный ключ (`todo.id`). Это позволяет React эффективно обновлять только измененные элементы, минимизируя количество перерисовок.

Ключи особенно важны при работе со списками, которые могут изменяться во времени, например, при добавлении, удалении или переупорядочивании элементов.

**[⬆ Наверх](#содержание)** 


### Является ли key обязательным?   

Нет, не является. Но по умолчанию React в качестве значения для key будет использовать индекс элемента.  

**[⬆ Наверх](#содержание)**   

### Можем ли мы в качестве key использовать индекс элемента массива?  

Если порядок расположения элементов гарантированно не будет изменяться, то можем. В противном случае - нет. 

**[⬆ Наверх](#содержание)**  

### Что можно использовать в качестве key как альтернатива индексу элемента массива?  

В качестве ключей нужно использовать уникальные идентификаторы. Например, id из базы данных.

**[⬆ Наверх](#содержание)**  

### С какой версией React приходилось работать?   

C 16.8 и выше.

**[⬆ Наверх](#содержание)**

### Какие методы жизненного цикла компонентов вы знаете?

В React компоненты проходят через ряд этапов своего "жизненного цикла", включая следующие методы:

1. **constructor(props)**: Вызывается при создании компонента. Здесь происходит инициализация состояния и привязка методов.

2. **componentDidMount()**: Вызывается после того, как компонент был вставлен в DOM. Часто используется для загрузки данных с сервера.

3. **componentDidUpdate(prevProps, prevState)**: Вызывается после обновления компонента. Позволяет реагировать на изменения пропсов или состояния.

4. **shouldComponentUpdate(nextProps, nextState)**: Позволяет оптимизировать обновления компонента, возвращая `false`, если обновление не требуется.

5. **componentWillUnmount()**: Вызывается перед удалением компонента из DOM. Используется для очистки ресурсов.

6. **static getDerivedStateFromProps(props, state)**: Редко используется. Позволяет обновить состояние на основе новых пропсов.

7. **getSnapshotBeforeUpdate(prevProps, prevState)**: Редко используется. Позволяет получить информацию из DOM перед его обновлением.

8. **componentDidCatch(error, info)**: Используется для обработки ошибок в дочерних компонентах.

Это лишь краткий обзор методов жизненного цикла компонентов в React.

**[⬆ Наверх](#содержание)**


### Какие методы жизненного цикла были убраны в React 16?
В React 16 были удалены следующие методы жизненного цикла:

1. `componentWillMount`: Этот метод вызывался перед рендерингом компонента. Вместо него рекомендуется использовать `constructor` или `componentDidMount`, в зависимости от сценария.

2. `componentWillReceiveProps`: Этот метод вызывался перед тем, как компонент получал новые пропсы. Теперь его рекомендуется заменить на `componentDidUpdate`, где вы можете сравнить предыдущие и текущие пропсы.

3. `componentWillUpdate`: Этот метод вызывался перед обновлением компонента. Вместо него можно использовать `componentDidUpdate`.

Эти изменения были внесены, чтобы сделать жизненный цикл более предсказуемым и избежать проблем, связанных с асинхронностью вызовов методов. Если вам нужно выполнять действия в определенных моментах жизненного цикла компонента, обновите свой код с учетом этих изменений.

**[⬆ Наверх](#содержание)**


### Какие нововведения были добавлены в React 16?

React 16, также известный как React Fiber, внес множество значительных изменений и нововведений:

1. **Fiber Architecture**: Была введена новая архитектура под названием Fiber, которая позволила React более эффективно обрабатывать обновления компонентов, делая приложения более отзывчивыми.

2. **Portals**: Была добавлена возможность использовать Portals, позволяющие рендерить дочерние компоненты за пределами иерархии DOM-узлов родительского компонента. Это полезно, например, для создания модальных окон или всплывающих меню.

3. **Error Boundaries**: Введены Error Boundaries, которые позволяют изолировать ошибки в компонентах, предотвращая падение всего приложения. Это помогает улучшить стабильность интерфейса.

4. **Fragment**: Появился новый компонент Fragment, который позволяет группировать дочерние элементы без добавления лишних DOM-узлов.

5. **Сustom DOM Attributes**: Теперь можно передавать пользовательские атрибуты в DOM-элементы без предупреждений.

6. **Server-Side Rendering Improvements**: Улучшения в механизмах SSR (Server-Side Rendering) с помощью новых API и оптимизаций.

7. **Return Types**: Введены новые типы возвращаемых значений для компонентов, такие как `string` и `number`, что позволяет использовать элементы возвращаемые функциональными компонентами в качестве дочерних элементов.

8. **Поддержка Map и Set**: React Elements теперь могут быть созданы из экземпляров Map и Set.

9. **Более компактный React**: Размер библиотеки был уменьшен за счет оптимизаций и удаления устаревшего кода.

10. **Новые Warnings и Deprecations**: Были внесены изменения в систему предупреждений, а также удалены устаревшие методы.

11. **Новый рендерер**: Добавлен новый экспериментальный рендерер под названием Scheduler, который позволяет контролировать приоритеты рендеринга для лучшей отзывчивости интерфейса.

12. **Событийный обработчик onFocus**: Введена поддержка обработчика `onFocus` для обработки фокусировки на элементах.

13. **Новый атрибут forwardRef**: Добавлен атрибут `forwardRef`, упрощающий передачу ref'ов между компонентами.

**[⬆ Наверх](#содержание)**


### Что такое "хуки" (hooks) в React и для чего они используются?

Хуки (hooks) в React - это функции, которые позволяют вам "зацепиться" за внутреннее состояние и функциональности React компонентов. Они были представлены в React 16.8 и позволили функциональным компонентам использовать состояние и другие возможности, которые ранее были доступны только классовым компонентам. Хуки позволяют писать более чистый, читаемый и переиспользуемый код.

Примеры хуков:

1. **useState**: Позволяет функциональным компонентам иметь локальное состояние. Вы можете определить переменные состояния и функции для их обновления. Пример:

```jsx
import React, { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

2. **useEffect**: Позволяет выполнять побочные эффекты в функциональных компонентах. Например, выполнение кода после рендеринга компонента, работа с асинхронными запросами и подписками. Пример:

```jsx
import React, { useState, useEffect } from "react";

function DataFetching() {
  const [data, setData] = useState([]);

  useEffect(() => {
    fetchData(); // Здесь может быть код для получения данных
  }, []);

  return (
    <ul>
      {data.map((item) => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}
```

3. **useContext**: Позволяет получать доступ к контексту из компонента. Контекст - это способ передачи данных глубоко в дерево компонентов без явной передачи через пропсы. Пример:

```jsx
import React, { useContext } from "react";
import { ThemeContext } from "./ThemeContext";

function ThemedButton() {
  const theme = useContext(ThemeContext);

  return (
    <button style={{ background: theme.background, color: theme.color }}>
      Themed Button
    </button>
  );
}
```

Хуки позволяют разбивать логику на более мелкие и управляемые части, делая компоненты более чистыми и легко тестируемыми. Они также устраняют необходимость в классовых компонентах в большинстве случаев, что делает код более понятным и сокращает объем бойлерплейта.

**[⬆ Наверх](#содержание)**   

### Какие знаешь хуки?   

1. useState
2. useEffect
3. useContext
4. useRef
5. useLayoutEffect
6. useMemo
7. useCallback
8. useReducer
9. useImperativeHandle
10. useDebugValue   
11. useDeferredValue
12. useInsertionEffect
13. useSyncExternalStore
14. useTransition
15. useId
16. use
17. useActionState
18. useOptimistic

**[⬆ Наверх](#содержание)**   


### Какие хуки используешь на работе?  
1. useState
2. useEffect
3. useRef
4. useCallback
5. useMemo

**[⬆ Наверх](#содержание)**


### Какой хук является аналогом componentDidMount? 

 Аналогом componentDidMount является хук useEffect c пустым массивом зависимостей.

**[⬆ Наверх](#содержание)**

### Как работает хук `useEffect`?



### Какие особенности имеют хуки `useEffect` и `useLayoutEffect`?

`useEffect` и `useLayoutEffect` - это два хука в React, которые позволяют выполнять побочные эффекты в функциональных компонентах. Однако у них есть некоторые отличия:

1. **Время выполнения:**

  - `useEffect`: Этот хук выполняет побочные эффекты после того, как браузер обновил экран (после того, как произошел рендеринг и компонент отобразился на экране). Он не блокирует браузер и выполняется асинхронно.

  - `useLayoutEffect`: Этот хук выполняет побочные эффекты **синхронно**, немедленно после завершения рендеринга компонента и перед отображением изменений на экране. Он блокирует браузер до тех пор, пока все эффекты не будут выполнены.

2. **Использование:**

  - Оба хука используются для выполнения побочных эффектов, таких как отправка сетевых запросов, подписка на события или изменение DOM.

  - Разница заключается в том, что если вам нужно выполнить действия, зависящие от макета (layout) до того, как пользователь увидит обновленный интерфейс, вы можете использовать `useLayoutEffect`.

3. **Рекомендации:**

  - В большинстве случаев предпочтительно использовать `useEffect`, так как он не блокирует браузер и обычно достаточно эффективен для большинства сценариев.

  - `useLayoutEffect` стоит использовать тогда, когда вам **действительно** нужно выполнить побочные эффекты синхронно после рендеринга компонента.

Выбор между `useEffect` и `useLayoutEffect` зависит от конкретных требований вашего приложения и времени, в которое вы хотите, чтобы эффекты выполнились.

**[⬆ Наверх](#содержание)** 

### Что такое контекст (context) в React и для чего он используется?

Контекст (context) в React - это механизм, который позволяет передавать данные глубоко вниз по иерархии компонентов, минуя пропсы (props). Он используется, когда определенные данные нужны во множестве компонентов, и передача через каждый компонент становится неудобной.

Контекст позволяет создать "контекстное" окружение, в котором компоненты могут получать доступ к данным без необходимости явно передавать их через пропсы. Это особенно полезно для глобальных данных, таких как данные аутентификации, темы оформления и другие общие состояния.

онтекст состоит из двух частей: "поставщика" (provider) и "потребителя" (consumer).

**Поставщик (Provider):** Поставщик определяет данные, которые следует передать. Он оборачивает дерево компонентов, которые должны получить доступ к этим данным, и предоставляет методы для их доступа.

**Потребитель (Consumer):** Потребитель использует методы, предоставленные поставщиком, для доступа к данным, переданным через контекст.

Пример использования контекста:

```jsx
import React, { createContext, useContext } from "react";

// Создание контекста
const UserContext = createContext();

// Компонент-поставщик данных
const UserProvider = ({ children }) => {
  const user = { name: "John", role: "admin" };

  return <UserContext.Provider value={user}>{children}</UserContext.Provider>;
};

// Компонент, использующий контекст
const UserInfo = () => {
  const user = useContext(UserContext);

  return (
    <div>
      <p>Name: {user.name}</p>
      <p>Role: {user.role}</p>
    </div>
  );
};

// Главный компонент, который оборачивает приложение в провайдер данных
const App = () => {
  return (
    <UserProvider>
      <UserInfo />
    </UserProvider>
  );
};

export default App;
```

В этом примере контекст `UserContext` используется для передачи информации о пользователе от `UserProvider` до `UserInfo`, минуя пропсы. Компонент `UserInfo` использует хук `useContext`, чтобы получить доступ к данным контекста.

Контекст следует использовать осторожно и только там, где это действительно необходимо, так как это может усложнить понимание взаимодействия компонентов и усложнить отладку.
**[⬆ Наверх](#содержание)**


- Каковы условия переотрисовки компонента? 
  Ответ: 
     1. [x] _изменение локального стейта_
     2. [x] _изменение пропсов_
     3. [x] _переотрисовка родительского компонента_
     4. [x] _изменение контекста_

  
  


- **С какой версией React приходилось работать?**  
  Ответ:     


- **Как выглядит жизненный цикл классового компонента?**  
  Ответ: 
     1. [x] componentDidMount
     2. [x] componentDidUpdate
     3. [x] componentWillUnmount
     4. [x] componentDidCatch
     5. [x] shouldComponentUpdate    
  
- **Какой аналог componentDidMount появился в версии 16.8?**    
  Ответ: _useEffect_    


- **Что такое useEffect?**   
  Ответ: _Это один из хуков. Он вызывается асинхронно, не блокирует рендер. Там можно прописывать сайд-эффекты: запросы на сервер, подписки, манипуляции с DOM.   
   Если нужно вызвать только один раз после монтирования компонента, нужно передать пустой массив зависимостей.   
   Можно также вернуть cleanup-функцию, которая будет вызваться перед размонтированием компонента.  
   Может вызываться также при изменении зависимостей (обновлении компонента).  
   В таком случае useEffect вызывает cleanup-функцию со старыми значеними, потом повторно useEffect c новыми._   


- **Какие знаешь хуки?**   
  Ответ:  
     1. [x] useState
     2. [x] useCallback
     3. [x] useMemo
     4. [x] useLayoutEffect - вызывается синхроннно и может блокировать отрисовку
     5. [x] useReducer
     6. [x] useContext
     7. [x] useRef
     8. [x] useId     
  

- **Какие хуки используешь на работе?**  
  Ответ:    


- **В чем разница между useCallback и useMemo?**   
  Ответ: 
    1. [x] _useCallback - для мемоизации функции, принимает какой-либо коллбэк и мемоизирует ссылку, т.е при каждом рендере ссылка на функцию будет не изменна.  
  Примимает массив зависимостей, ссылка на коллбэк будет изменяться только тогда, когда будут меняться зависимости._ 
    2. [x] _useMemo также принимает коллбэк и мемоизирует возвращаемое из него значение._          


- **Как принимаешь решение об использовании useMemo и useCallback?**    
  Ответ: 


- **Для чего нужен React.memo? Какие аргументы принимает?**   
   Ответ: _Для мемоизации компонента с целью оптимизировать лишние переотрисовки.  
   Принимает два аргумента: 1 - сам компонент, 2 - опциональную функцию сравнения пропсов, возвращающая булево значение._

  

- **Что такое prop drilling?**   

   Ответ: _Прокидывание данных через несколько компонентов._    


- **Может ли контекст являться заменой стейт-менеджерам?**   
  Ответ: _Нет. Например, нет поддержки асинхронных экшенов, devtools-инструментов.  
  Также при изменении контекста происходит ререндеринг всех потребителей этого контекста, т.е все что обернуто в Provider._   

  


  


