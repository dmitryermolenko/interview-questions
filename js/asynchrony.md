Список материалов:

- https://www.youtube.com/watch?v=zDlg64fsQow&t=84s&ab_channel=UlbiTV


Вопросы:

1. Какой метод позволяет выполнить код через заданные промежутки времени?

Ответ: setInterval()
<----------------------------------------------------------------------------------------------> 
2. Что такое  и как работае Event Loop?

Ответ:
- Event Loop не является частью js
- JS - однопоточный синхронный и блокирующий язык, т.е в некий момент времени он может выполнять лишь какую-то одну задачу. Пока не будет выполнена текущая задача, следующая задача не будет начата.
- Как только вызывается функция, ее контекст вызова попадает в callstack - это структура данных, в которой хранится информация о том, где мы сейчах находимся в программе.
- После выполнения функции контекст ее вызова удаляется из callstack.
- Такой механизм работы подходит для синхронных операций. А что на счет асинхронных?
- Асинхронные операции обрабатываются браузерным Web API, т.е, например, регистрируются коллбэки, переданные в setTimeout/setInterval, и запускается таймер, или переданныйе в addEventListener, и отслеживается событие, или переданные в промис, и остеживается, когда промис зарезолвится
- Как только таймер истечет, или наступит пользовательское событие, или промис зарезолвится, зарегистрированные коллбэки попадают либо в очередь макрозадач, либо в очередь микрозадач
- Task queue - очередь макрозадач, сюда попадают коллбэки из таймеров и обработчиков событий

Сразу после каждой макрозадачи на той же итерации событийного цикла движок исполняет все задачи из очереди микрозадач перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё.
Все микрозадачи завершаются до обработки каких-либо событий или рендеринга, или перехода к другой макрозадаче.

!!! Just remember — SYNC tasks → MICRO tasks → MACRO tasks !!! 3.

3. 
```
console.log("start");
setTimeout(function() {
  console.log('timer1');
  setTimeout(function() {
    console.log('timer2');
  }, 0);
}, 0);

setTimeout(function() {
  console.log('timer3');
}, 0);

console.log('end');

```

Ответ: start, end, timer1, timer3, timer2
<-------------------------------------------------------------------------------------------->

4. 
```
console.log(1)
setTimeout(() => {
  console.log(2)
});
Promise.resolve().then(() => console.log(3))
console.log(4);
```

Ответ: 1, 4, 3, 2
<--------------------------------------------------------------------------------------------------------------------> 

5.
```
console.log(1)
setTimeout(() => {
  queueMicrotask(() => {
    console.log(2)
});
  Promise.resolve().then(() => console.log(8))  
  console.log(3);
});
Promise.resolve().then(() => console.log(4))
queueMicrotask(() => {
  console.log(5)
  queueMicrotask(() => {
    console.log(6)
  });
});
console.log(7)
```

Ответ: 1, 7, 4, 5, 6, 3, 2, 8
<--------------------------------------------------------------------------------------------------------------------> 

6. Что такое Promise? Для чего он нужен?

Ответ:

- Promise – это специальный объект, используемый для асинхронных запросов.
- При создании new Promise((resolve, reject) => ...) автоматически запускается функция-аргумент, которая должна вызвать resolve(result) при успешном выполнении и reject(error) – при ошибке.
- Promise содержит своё состояние: вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).
- Promise является связующим звеном между 'создающим' кодом и 'потребительским', который получает либо результат, либо ошибку
- Чтобы обработать результат или ошибку нужно назначить обработчики через методы .then() и .catch
- Для передачи результата от одного обработчика к другому используется чейнинг
- Promise позволяют использовать chaining для последовательности из нескольких асинхронных запросов
- then возвращает Promise со значением, которое возвращено обработчиками onFullfilled/onRejected
  <-------------------------------------------------------------------------------------------------------------------->

7. Как создать Promise? В чем разница при создании промисов с помощью конструктора и с помощью фабрики?

Ответ:
<--------------------------------------------------------------------------------------------------------------------> 

8. Методы then и catch. Что делают? Что такое promise chaining? Что могут возвращать их коллбэки и как это повлияет на состояние промиса, возвращаемого данным then или catch?

Ответ: Методы then и catch навешивают обработчики. Promise chaining - цепочка промисов, позволяющая обрабатывать несколько асинхронных задач подряд. Их коллбэки могут возвращать 'простые' значения, в этом случае then возвратит разрешенный promise со значением, возвращенным коллбэком. Могут возвращать promise, тогда promise, возвращаемый then'oм находится в состоянии pending до тех пор, пока promise, возвращенный коллбэком, не разрешится успешно или неуспешно
<--------------------------------------------------------------------------------------------------------------------> 

9. В чем отличие then(resolveHandler).catch(rejectHandler) и then(resolveHandler, rejectHandler)?

Ответ:
<-------------------------------------------------------------------------------------------------------------------->

10. Рассказать про методы:
Promise.resolve - возвращает успешно выполнившийся промис с результатом, переданным в resolve
Promise.reject - возвращает промис с ошибкой error, переданной в reject
Promise.all - ожидает выполнения всех промисов и возвращает массив с результатами. Если любой из указанных промисов вернёт ошибку, то результатом работы Promise.all будет эта ошибка, результаты остальных промисов будут игнорироваться.
Promise.race - ожидает первый выполненный промис, который становится его результатом, остальные игнорируются.

Ответ:
<--------------------------------------------------------------------------------------------------------------------> 

11. В чем преимущества и недостатки коллбэков и промисов?

Ответ:
<--------------------------------------------------------------------------------------------------------------------> 

12. Какие значение и состояние будут у следующего промиса и почему:

```
const promise = new Promise((resolve, reject) => {
  resolve(0);
  reject(1);
  resolve(2);
});

```

Ответ: 0
<--------------------------------------------------------------------------------------------------------------------> 13. Что выведет код ниже?
let promise = new Promise(function(resolve, reject) {
resolve(1);
setTimeout(() => resolve(2), 1000);
});

promise.then(data => console.log(data));

Ответ: 1.

Второй вызов resolve будет проигнорирован, поскольку учитывается только первый вызов reject/resolve. Все последующие вызовы – игнорируются
<--------------------------------------------------------------------------------------------------------------------> 14. Функция delay(ms) должна возвращать промис, который перейдёт в состояние «выполнен» через ms миллисекунд, так чтобы мы могли добавить к нему .then
delay(3000).then(() => console.log('выполнилось через 3 секунды'));

Ответ: function delay(ms) {
return new Promise(resolve => setTimeout(resolve, ms));
}
<--------------------------------------------------------------------------------------------------------------------> 15. const p = new Promise(resolve => {
setTimeout(() => {
console.log('1');
resolve();
}, 2000)
}
);

p.then(() => console.log('2'));

console.log('3');

setTimeout(() => console.log('4'), 3000);

Ответ: 3, 1, 2, 4
<--------------------------------------------------------------------------------------------------------------------> 16. Есть «обычная» функция. Как можно внутри неё получить результат выполнения async–функции?
async function wait() {
await new Promise(resolve => setTimeout(resolve, 1000));

return 10;
}

function f() {
}

Ответ: function f() {
wait().then(result => alert(result));
}
<--------------------------------------------------------------------------------------------------------------------> 17. function func1(){
setTimeout(()=>{
console.log(x);
console.log(y);
},3000);

var x = 2;
let y = 12;
}

func1();

Ответ: 2, 12. Несмотря на то, что обращение к переменной y происходит до ее объявления, код, где просиходит это обращение - асинхронный, на момент его выполнения переменная y будет доступна
<--------------------------------------------------------------------------------------------------------------------> 18. (function(){
setTimeout(()=> console.log(1),2000);
console.log(2);
setTimeout(()=> console.log(3),0);
console.log(4);
})();

Ответ: 2, 4, 3, 1
