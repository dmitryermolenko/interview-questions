### Секция "Общие вопросы по JavaScript"   

- **Какие нововвдения привнес ES6(ES2015)?**  
  Ответ:
    1. [x] let, const
    2. [x] стрелочные функции
    3. [x] деструктуризация
    4. [x] spred/rest операторы
    5. [x] классы
    6. [x] параметры по умолчанию
    7. [x] шаблонные строки
    8. [x] промисы
    9. [x] for ... of
    10. [x] модули
    11. [x] Symbol
    12. [x] Map и Set
    13. [x] итераторы и генераторы       
  

- **Зачем нужен use strict?** 

  Ответ: _Запускает код в современном режиме, по факту - это такой багфикс, которые были допущены в предыдущих спецификациях._

  

### Секция "Типы данных"

- **Какие типы данных выделяют в JavaScript?**  
  Ответ: _Выделяют следующие типы данных:_ 
  1. [x] String
  2. [x] Number
  3. [x] Boolean
  4. [x] BigInt
  5. [x] undefined
  6. [x] null
  7. [x] Symbol
  8. [x] Object  


- **На какие группы делятся вышеупомянутые типы данных?**  
  Ответ: _простые (примитивы) и сложные (ссылочные)_  


- **Чем примитивный тип данных отличается от ссылочного типа?**   
  Материалы для изучения:  
   - https://doka.guide/js/ref-type-vs-value-type/  
  
  Ответ: _Примитивные типы данных отличаются от сложных способом хранения и  передачи значений. В простых типах передача значений происходит по значению, т.е при копировании простого значения в новую переменную эти значения начинают существовать независимо друг от друга, т.е изменение значения в одной переменной не влечет изменений в другой переменной.
  В ссылочных типах происходит копирование не самого значения, а ссылки на ячейку памяти, в которой находится ссылочный тип данных. Это означает, что две переменные теперь ссылаются на одну и ту же ячейку памяти, поэтому при изменении/удалении/добавлении некоторого св-ва объекта или элемента массива в одной переменной приведут к таким же изменениям в другой переменной_  


- **К какому типу данных относится функция?**  
  Ответ: _К объекту._  


- **Чем похожи объекты, массивы и функции?**  
  Ответ: _Это все объекты._  


- **Как отличить массив от объекта? Чем массив отличается от объекта?**  
  Ответ: Как минимум визуально: массив можно создать через конструктор `new Array()`, либо через `литерал []`, а объект - `new Object()`, либо через `литерал {}`  
   ` Array.isArray()` - определяет, является ли значение массивом  
   ` instanceof Array` - определяет, является ли значение экземпляром класса Array


- **В чем отличие null от undefined?**  
  Ответ: `undefined `_- значения нет, неизвестно, переменную создали, но значение не задали, или переменной вообще такой нет_
  _`null` - значение есть, оно пустое, переменную создали, значение задали_  


- **Какие есть инструменты для работы с типами?**   
  Ответ: _`TypeScript`, возможно еще нативный оператор для проверки типов `typeOf`, метод конструктора массива для проверки того факта, что значение является массивом - `Array.isArray()`_  


- **Почему у примитивов есть возможность вызвать методы?**  
  Ответ: _Механизм "boxing"("упаковка") - при вызове метода у примитива примитив оборачивается в соответствующий объект, и на нем через прототип вызывается метод._  


- **Какие типы данных относятся к мутабельным и иммутабельным?**  
  Ответ: _примитивы - иммутабельные, ссылочные - мутабельные_    


### Секция "Операторы"    

- **Какие существуют операторы в JavaScript?**  
  Ответ: 
  1. [x] сложения
  2. [x] вычитания
  3. [x] умножения
  4. [x] деления
  5. [x] остаток от деления
  6. [x] конкатенации
  7. [x] сравнения
  8. [x] присваивания
  9. [x] логические   


- **Какая существует разница между строгим и нестрогим сравнением?**  
  Ответ: _При нестрогом сравнении происходит неявное приведение типов в последующим сравнением значений, при строгом - сравниваются типы и значения._   

- **Какие существуют логические операторы и в чем особенность их работы?**  
  Ответ: 
  1. [x] _`&&` (логическое и)_
  2. [x] _`|| `(логическое или)_
  3. [x] _`! `(логическое отрицание)_     
  

- **Что является `falsy` значениями?**
  Ответ: 
   1. [x] null
   2. [x] undefined
   3. [x] false
   4. [x] ''
   5. [x] 0
   6. [x] NaN (не равен ни себе, ни чему-либо еще)


- **Какие есть способы объявления переменных?**  
  Ответ: _var, let, const_   


- **В чем различие между const, let, var?** 

  Ответ: 
  1. [x] _const/let vs var - блочная область видимости vs функциональная область видимости_
  2. [x] _const/let vs var - отсутствие хойстинга vs хойстинг_
  3. [x] _let vs var - невозможность использовать несколько переменных с одинаковыми именами vs возможно переопределять имя переменной_
  4. [x] _const vs let - невозможность переопределять значение vs возможность переопределять значение_    
  

- **Что такое область видимости? Как она работает? Какие бывают?**  
  Ответ:   


- **Зачем нужна блочная видимость, если есть функциональная?**  
  Ответ:     


- **Что такое всплытие? Что может всплывать?**   
  Ответ: 
  

  

### Секция "Функции"

- Какие существуют типы функций по способу их объявления?  
  Ответ:
  1. [x] Function expression (Функциональное выражение)
  2. [x] Function declaration (Объявление функции)
  3. [x] Arrow function (Стрелочная функция)   
  

- **В чем разница между Function declaration и Function expression?**
  Ответ:  


- **Зачем нужны стрелочные функции?**  
  Ответ:   


- **Что такое чистые функции?**  
   Ответ: _Функции, которые имееют детерминированный результат и не имеют побочные эффекты._  


- **Зачем нужны чистые функции?**
  Ответ: _Чистые функции используются в функциональном программировании, где нет состояния.
  Они проще для понимания, для отлаживания, т.к не зависят ни от какого состояния, не изменяют к-л состояние._    


- **Что такое контекст в функции?**  
  Ответ: _Это объект, в рамках которого вызвалася функция/метод. Ссылку на этот объект можно получить через ключевое слово this. Контекст динамичен и напрямую зависит от того, как метод/функция были вызваны.
  Контекстом могут выступать:_
  1. [x] _Сам объект, в котором был определен метод, если метод вызывается непосредственно у объекта._
  2. [x] _Глобальный объект Window или undefined (для strict mode) для вызова функций, не использующих синтаксис стрелочных функций, а также методов объектов, вызываемых отдельно от объектов, например, при отложенных вызовах (как коллбэки, или вызов в таймерах/таймаутах)._
  3. [x] _Внутри функции-конструктора/класса - это вновь создаваемый объект._
  4. [x] _У стрелочных функций нет контекста, поэтому определяется не тем фактом, где она вызвана, а где была определена, т.е не имея своего контекста, она берет в качестве контекста ближайший контекст._   
  
  
- **Существует ли возможность переопределять контекст?**     
  Ответ: _Да, для изменения контекста существуют следующие методы:_
    1. [x] call
    2. [x] apply
    3. [x] bind  

- **Чем контекст отличается от области видимости?**  
  Ответ:   



- **Что такое замыкание?**  
  Ответ:
  Вызов внешней функции предполагает создание внутренней функции. У любой функции при создании есть скрытое поле [[Environement]], предназначенное для хранение ссылки на то место, где эта функция была создана (т.е по факту на внешнее лексическое окружение, т.е лексическое окружение, созданное внешней функцией при ее вызове). 

  Поэтому даже после вызова внешней функции и удалении ее из стека при вызове внутренней функции будет создаваться еще одно скрытое поле [[LexicalEnvironement]], которое хранит в себе объект из двух полей:
  1 - содержит все локальные переменные функции
  2 - как раз-таки и содержит ссылку на внешнее лексическое окружение, ссылка эта берется из поля [[Environement]], в которое и была ранее записана ссылка при создании внутренней функции.  
  Таким образом внутренняя функция всегда будет иметь доступ к переменным из внешнего лексического окружения, т.е переменные внешней функции как бы замкнуты внутренней функцией, извне они не доступны   


### Секция "Массивы"   

- **Приходилось ли тебе когда-либо сортировать массив с числами? Как бы ты это сделал?**  
Ответ: _Метод sort, с передачей функции сравнения, которая будет возвращать результат a - b: если результат < 0, a будет стоять левее, в противном случае - правее._    

- **С какими перебирающими методами массива ты знаком?**
  Ответ: 
     1. [x] map
     2. [x] reduce
     3. [x] filter
     4. [x] forEach
     5. [x] find
     6. [x] findIndex
     7. [x] findLastIndex
     8. [x] indexOf
     9. [x] lastIndexOf
    10. [x] some
    11. [x] every
    12. [x] sort
    13. [x] includes    
  

- **В чем принципиальное отличие `forEach` от `map`?**  

  Ответ: _`map` возвращает новый массив, а `forEach` позволяет просто проитерироваться по массиву_   


- **Зачем нам нужны перебирающие методы, если есть цикл `for`?**  
  Ответ: _Каждый метод заточен под решение конкретной задачи, он более компактен в написании, нежели простой цикл for, где придется самому писать много лишнего.
  for имеет смысл использовать для того, чтобы избежать просадки производительности, когда за одну итерацию можно сделать несколько вещей, например, смапить и отфильтровать,
  потому использование для этих задач отдельно map и filter предполагает двойной проход по массиву_


### Секция "Объекты"   

- **Как сделать какое-либо свойство объекта неизменяемым?**  
  Ответ:     


- **Как решить проблему: обращение к свойству объекта, которое может отсутствовать, чтобы не выбросить ошибку?**  
  Ответ: _optional оператор_



- **В чем разница между глубоким и поверхностным копированием?**

  Ответ:  _При неглубоком копировании все не примитивы (объекты/массивы) копируются по ссылке.
  При глубоком копировании - все вложенные объекты/массивы имеют ссылки отличные от ссылок оригинальных объектов/массивов._    


- **Какие существуют способы поверхностного копирования?**  
  Ответ:
    1. [x] _`Object.assign()`_
    2. [x] _`spred-оператор`_    
  

- **В чем состоит отличие `Object.assign()` и `spread-оператора` при копировании?**  
  Ответ: _`Object.assign()` вызовет геттер, но они оба не скопируют сеттеры._  


- **Какие существуют способы глубокого копирования?**  
  Материалы для изучения:
  https://surma.dev/things/deep-copy/  
  Ответ:

   1. [x] JSON.parse(JSON.stringify()) (но есть проблемы с копированием функций, символов, рекурсивных объектов)
   2. [x] Рекурсия (но есть проблемы с переполнением стека)
   3. [x] cloneDeep из lodash, clone из ramda
   4. [x] message channel (хз, че такое)
   5. [x] history API

### Секция "Прототипное наследование"

- **Что происходит, когда мы пишем ключевое слово new?**  
  Ответ:

  1. [x] _создается новый объект и ссылка на него присваивается в this_
  2. [x] _добавляются св-ва к this_
  3. [x] _возвращается this_


- **Почему для создания объектов не можем использовать обычную функцию?**

  Ответ: _В таком случае не будет связи данных с методами._   


- **Что такое прототипы и прототипное наследование?**
  Ответ:   

- **Почему патчинг прототипов - это плохо?**
  Ответ: _Манкипатчинг - это расширение базовых прототипов, возможно в будущем новый метод войдёт в следующую спецификацию и будет обладать другим поведением._    


- **Чем ООП в js отличается от ООП в других языках?**  
  Ответ:  


- **В чем заключается отличие классов в Javascript от классов в других языках?**  
  Ответ:



- **Как дабавить статический метод в prototype без классов?**  
  Ответ:





### Секция "Асинхронность"    

- **Чем отличается синхронный код от асинхронного?**  
  Ответ: _Синхронный код выполняется сразу и возвращает сразу результат, асинхронный код выполняется сразу, но результат вовзращает через некоторое время._ 


- **Что такое event loop?**  
  Ответ:   


- **Что такое Promise?**  
  Ответ:   


- **Что нам дал Promise своим появлением?**  
  Ответ: _Избавил от callback-hell, большой вложенности и нечитаемости._ 


- **Как выполнить некоторую операцию независимо от результата выполнения Promise?**   
  Ответ: _Через метод `finally`._


### Секция "DOM"   

- **Что такое DOM?**  
  Ответ:   


- **Чего можно достичь, манипулируя DOM?**  
  Ответ:    


- **В чем отличие атрибутов html от свойств DOM-объекта?**  
  Ответ:  


- **Пропадет ли DOM, если мы отключим JavaScript?**  
  Ответ: _Нет_   


- **Как понять, что DOM загружен?**
  Ответ: _Подписаться на событие `DOMContentLoaded`._     


- **Как просмотреть все атрибуты на каком-то DOM-узле?**
  Ответ: _console.dir()_ 


- **Как получается, что на всех DOM-узлах есть одни и те же св-ва (class, id т.д)?**  
  Ответ: _Наследуются от общего родителя._

- **В чем отличие .getElementsByClassName от .querySelectorAll?**
  Ответ:


- **За счет чего достигается интерактивность в вебе?**  
  Ответ: _За счет событий._
 


- **Какие существуют типы событий?**  
  Ответ:
   1. [x] _события документа_
   2. [x] _события мыши_
   3. [x] _события ввода_
   4. [x] _события клавиатуры_
   5. [x] _события touch_    
  

- **Какие есть способы навесить обработчики событий?**
  Ответ:
  1. [x] в html - через атрибуты, например, onclick
  2. [x] в js - addEventListener, свойства событий, например, onclick/onfocus и т.д  


- **Какой способ подходит, если нужно несколько обработчиков на одно и то же событие навесить?**   
  Ответ: _addEventListener_


- **Что такое событийная модель? Как она работает?**  
  Ответ: _Событие погружается, начиная с window, доходит до элемента, на которм произошло событие и всплывает снова до window._  


- **Что такое делегирование события?**  
  Ответ:   


- **Как сфокусироваться на элементе?**  
  Ответ: _Метод `focus()`_  


- **Как снять фокус с элемента?**  
  Ответ: _Метод `blur()`_   


- **Как отловить, что пользователь сфокусировался или потерял фокус?**  
  Ответ: Навесить обработчик события на события `focus `и `blur`.

